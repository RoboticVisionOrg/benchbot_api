#include "benchbot/benchbot.hpp"

#include <jsoncpp/json/json.h>
#include <opencv2/opencv.hpp>
#include <curl/curl.h>
#include <vector>

static const std::string base64_chars = 
             "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
             "abcdefghijklmnopqrstuvwxyz"
             "0123456789+/";

static inline bool is_base64(unsigned char c);
std::string base64_decode(std::string const& encoded_string);

BenchBot::BenchBot(std::string uri) : uri(uri) {
    curl = curl_easy_init();
    if (curl) {
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, this);
    }
}
BenchBot::~BenchBot() {
    curl_easy_cleanup(curl);
}

Json::Value BenchBot::get(std::string route) {
    Json::Value root;   
    Json::Reader reader;

    if (!curl) {
        return std::string();
    }
    
    message = std::string(); // Reset message container
    
    curl_easy_setopt(curl, CURLOPT_URL, (uri + route).c_str());
    res = curl_easy_perform(curl);

    if (res != 0) {
        return root;
    }

    if (!reader.parse(message.c_str(), root)) {
        return root;
    }

    return root;
}

Json::Value BenchBot::send(std::string route, Json::Value data) {
    Json::Value resp;   
    Json::Reader reader;
    Json::FastWriter writer;
    
    std::string buffer = writer.write(data);

    if (!curl) {
        return std::string();
    }

    message = std::string(); // Reset message containe

    struct curl_slist *hs=NULL;
    hs = curl_slist_append(hs, "Content-Type: application/json");

    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, hs);
    curl_easy_setopt(curl, CURLOPT_URL, (uri + route).c_str());
    curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, (long)buffer.length());
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, buffer.c_str());
    res = curl_easy_perform(curl);

    if (!reader.parse(message.c_str(), resp)) {
        return resp;
    }

    return resp;
}

cv::Mat BenchBot::getImage(std::string route) {
    Json::Value root = get(route);
    std::string buffer = root.get("image", "").asString();
    
    if (buffer.length() == 0) {
        return cv::Mat();
    }

    buffer = base64_decode(buffer);
    std::vector<char> data(buffer.c_str(), buffer.c_str() + buffer.length());
    
    return cv::imdecode(data, cv::IMREAD_COLOR);
}

GridMap BenchBot::getGridMap(std::string route) {
    Json::Value root = get(route);
    return GridMap(root["info"], root["data"], root["header"]);
}

bool BenchBot::isDone() {
    Json::Value root = get("is_done");
    return root.get("result", "false").asBool();
}

/**
 * Returns the status code generated by curl_easy_perform (e.g. CURLE_OK=0)
 * @return int status code
 */
int BenchBot::status() {
    return res;
}

size_t BenchBot::write_data(void *buffer, size_t size, size_t nmemb, void *userp) {
    ((BenchBot*)userp)->message.append((char*)buffer);
    return size * nmemb;
}


static inline bool is_base64(unsigned char c) {
  return (isalnum(c) || (c == '+') || (c == '/'));
}

std::string base64_decode(std::string const& encoded_string) {
  int in_len = encoded_string.size();
  int i = 0;
  int j = 0;
  int in_ = 0;
  unsigned char char_array_4[4], char_array_3[3];
  std::string ret;

  while (in_len-- && ( encoded_string[in_] != '=') && is_base64(encoded_string[in_])) {
    char_array_4[i++] = encoded_string[in_]; in_++;
    if (i ==4) {
      for (i = 0; i <4; i++)
        char_array_4[i] = base64_chars.find(char_array_4[i]);

      char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
      char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
      char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];

      for (i = 0; (i < 3); i++)
        ret += char_array_3[i];
      i = 0;
    }
  }

  if (i) {
    for (j = i; j <4; j++)
      char_array_4[j] = 0;

    for (j = 0; j <4; j++)
      char_array_4[j] = base64_chars.find(char_array_4[j]);

    char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
    char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
    char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];

    for (j = 0; (j < i - 1); j++) ret += char_array_3[j];
  }

  return ret;
}